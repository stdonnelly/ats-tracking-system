use mysql::{params, prelude::Queryable};
use time::Date;

use super::job_application_model::{
    HumanResponse, JobApplication, JobApplicationField, PartialJobApplication,
};

/// Get all job applications
pub fn get_job_applications<C: Queryable>(
    conn: &mut C,
) -> Result<Vec<JobApplication>, mysql::Error> {
    conn.query(
        "SELECT id, source, company, job_title, application_date, time_investment, human_response, human_response_date, application_website, notes
        FROM job_applications"
    )
}

/// Get all job applications where `human_response == None`
pub fn get_pending_job_applications<C: Queryable>(
    conn: &mut C,
) -> Result<Vec<JobApplication>, mysql::Error> {
    conn.query(
        "SELECT id, source, company, job_title, application_date, time_investment, human_response, human_response_date, application_website, notes
        FROM job_applications
        WHERE human_response = 'N'"
    )
}

pub fn get_job_application_by_id<C: Queryable>(
    conn: &mut C,
    id: i32,
) -> Result<Option<JobApplication>, mysql::Error> {
    conn.exec_first(
        "SELECT id, source, company, job_title, application_date, time_investment, human_response, human_response_date, application_website, notes
        FROM job_applications
        WHERE id = ?",
        (id,),
    )
}

pub fn search_job_applications<C: Queryable>(
    conn: &mut C,
    query: &str,
) -> Result<Vec<JobApplication>, mysql::Error> {
    // Add wildcards to the beginning and end of the query
    let query_with_wildcards = "%".to_owned() + &query.to_lowercase() + "%";
    conn.exec(
        "SELECT id, source, company, job_title, application_date, time_investment, human_response, human_response_date, application_website, notes
        FROM job_applications
        WHERE LOWER(source) LIKE :query
        OR LOWER(company) LIKE :query
        OR LOWER(job_title) LIKE :query",
        params! {"query" => query_with_wildcards}
    )
}

/// Insert a new job application, returning the new application with generated `id` and `application_date`.
///
/// `id` and `application_date` are automatically generated by the next available id and the current date, respectively.
pub fn insert_job_application<C: Queryable>(
    conn: &mut C,
    application: &JobApplication,
) -> Result<JobApplication, mysql::Error> {
    conn.exec_first(
        "INSERT INTO job_applications (source, company, job_title, application_date, time_investment, human_response, human_response_date, application_website, notes)
        VALUES (:source, :company, :job_title, :application_date, :time_investment, :human_response, :human_response_date, :application_website, :notes)
        RETURNING id",
        application
    )
    .map(|new_id| JobApplication {id: new_id.unwrap_or_default(), ..application.clone()})
}

/// Update the human response of a job application
///
/// `human_response_date` is optional. If `None`, the date is generated by mysql `NOW()` function
pub fn update_human_response<C: Queryable>(
    conn: &mut C,
    id: i32,
    human_response: HumanResponse,
    human_response_date: Option<Date>,
) -> Result<(), mysql::Error> {
    conn.exec_drop(
        "UPDATE job_applications
        SET human_response = :human_response, human_response_date = :human_response_date
        WHERE id = :id",
        params! {
            "id" => id,
            "human_response" => &human_response,
            "human_response_date" => human_response_date
        },
    )
}

pub fn update_job_application<C: Queryable>(
    conn: &mut C,
    application: &JobApplication,
) -> Result<(), mysql::Error> {
    conn.exec_drop(
        "UPDATE job_applications
        SET source = :source,
        company = :company,
        job_title = :job_title,
        application_date = :application_date,
        time_investment = :time_investment,
        human_response = :human_response,
        human_response_date = :human_response_date,
        application_website = :application_website,
        notes = :notes
        WHERE id = :id",
        application,
    )
}

/// Update a job application, returning the updated application.
///
/// `id` is used to determine what application to overwrite.
/// If there is no application with that id, nothing will be changed in the database and an error will be returned
pub fn update_job_application_partial<C: Queryable>(
    conn: &mut C,
    partial_application: PartialJobApplication,
) -> Result<(), mysql::Error> {
    let mut query_builder = "UPDATE job_applications".to_owned();

    // Loop over all field names
    // Flag for if this is the first variable
    let mut is_first = true;
    for field in partial_application.0.iter() {
        if let JobApplicationField::Id(_) = field {
            // NO-OP: Id is special because we are using it in the WHERE clause instead of SET
        } else if is_first {
            // The first non-id value is special because of where the SET and commas are
            query_builder += &format!(" SET {0} = :{0}", field.name());
            is_first = false
        } else {
            // Normal placement
            query_builder += &format!(",\n{0} = :{0}", field.name());
        }
    }

    // End with the WHERE clause
    query_builder += "\nWHERE id = :id";
    // RETURNING id, source, company, job_title, application_date, time_investment, human_response, human_response_date, application_website, notes";

    conn.exec_drop(query_builder, partial_application)
}

/// Delete a job application from the database
///
/// Not sure if I actually want this function
pub fn delete_job_application<C: Queryable>(conn: &mut C, id: i32) -> Result<(), mysql::Error> {
    conn.exec_drop(
        "DELETE FROM job_applications WHERE id = :id",
        params! {"id" => id},
    )
}
