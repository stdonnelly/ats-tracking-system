use mysql::prelude::Queryable;
use time::{Date, Duration};

/// A row in the job application table
#[derive(Debug)]
pub struct JobApplication {
    pub id: i32,
    pub source: String,
    pub company: String,
    pub job_title: String,
    pub application_date: Date,
    pub time_investment: Option<Duration>,
    pub automated_response: bool,
    pub human_response: HumanResponse,
    pub human_response_date: Option<Date>,
    pub application_website: Option<String>,
    pub notes: Option<String>
}

#[derive(Debug)]
pub enum HumanResponse {
    None,
    Rejection,
    InterviewRequest
}

/// Get all job applications
pub fn get_job_applications<C: Queryable>(conn: &mut C) -> Result<Vec<JobApplication>, mysql::Error> {
    conn.query_map(
        "SELECT id, source, company, job_title, application_date, time_investment, automated_response, human_response, human_response_date, application_website, notes FROM job_applications",
        map_row
    )
}

/// Get all job applications where `human_response == None`
pub fn get_pending_job_applications() -> Result<Vec<JobApplication>, Box<dyn std::error::Error>> {
    todo!()
}

/// Insert a new job application, returning the new application with generated `id` and `application_date`.
/// 
/// `id` and `application_date` are automatically generated by the next available id and the current date, respectively.
pub fn insert_job_application(application: JobApplication) -> Result<JobApplication, Box<dyn std::error::Error>> {
    todo!()
}

/// Update a job application, returning the updated application.
/// 
/// `id` is used to determine what application to overwrite.
/// If there is no application with that id, nothing will be changed in the database and an error will be returned
pub fn update_job_application(application: JobApplication) -> Result<JobApplication, Box<dyn std::error::Error>> {
    todo!()
}

fn map_row((
    id,
    source,
    company,
    job_title,
    application_date,
    time_investment,
    automated_response,
    human_response,
    human_response_date,
    application_website,
    notes): (
    i32,
    Option<String>,
    Option<String>,
    Option<String>,
    Option<Date>,
    Option<Duration>,
    Option<String>,
    Option<String>,
    Option<Date>,
    Option<String>,
    Option<String>
)) -> JobApplication {
    JobApplication {
        id,
        source: source.unwrap_or("".to_string()),
        company: company.unwrap_or("".to_string()),
        job_title: job_title.unwrap_or("".to_string()),
        application_date: application_date.unwrap_or(Date::from_ordinal_date(2000, 1).unwrap()),
        time_investment,
        automated_response: {
            if let Some(e) = automated_response {
                e.as_str() == "Y"
            } else {
                false
            }
        },
        human_response: {
            if let Some(human_response_unwrapped) = human_response {
                match human_response_unwrapped.as_str() {
                    "Interview request" => HumanResponse::InterviewRequest,
                    "Rejection" => HumanResponse::Rejection,
                    _ => HumanResponse::None
                }
            } else {
                HumanResponse::None
            }
        },
        human_response_date,
        application_website,
        notes
    }
}
